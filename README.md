<!--
 * @Author: lizhiyuan
 * @Date: 2020-11-21 20:53:10
 * @LastEditors: lizhiyuan
 * @LastEditTime: 2021-01-13 11:39:59
-->
# 操作系统

## 冯诺依曼存储思想

将程序和数据存放到计算机的内部存储器中,计算机在程序控制下一步一步的进行处理

计算机由五大部件组成:输入设备、输出设备、存储器、运算器、控制器

通俗的解释就是:计算机的工作原理是将程序放到内存中,然后用一个指针指向它(cs:ip),然后取指执行,取指执行.....

形象来看的话:当计算机打开一个APP应用的时候,实际是开启了一个进程,该进程会被操作系统自动执行...

总结: 取指 + 执行

## 操作系统启动简略

硬件上电后,操作系统在硬盘上(也有可能是在光盘中)

我们接下来要做的事儿就是把磁盘上的代码放入内存中,将cs:ip的指针指向它,让计算机取指执行

BIOS会先读取磁盘上的0磁道0扇区(1个扇区) ----> 0x07c00 引导扇区 bootsect.s (这时候会将07c00的内存空间腾出来,放到0x90000处执行....)

0x13中断继续读磁盘中的第2-5个扇区(4个扇区) ----> 0x90200(bootsect 512个字节,0x90000 + 512个字节  = 0x90200) setup.s

setup.s会将操作系统的代码移动到0地址--0x07c00的内存地址上去

最后setup.s会切换到保护模式,32位(寻址)模式.跳到0地址去执行操作系统的代码

***总结:BIOS ----> bootsect.s ----> setup.s -----> system***

main函数开始初始化操作系统,main函数永不退出,永不返回....
```c
void main(void){
    mem_init();
    trap_init();
    blk_dev_init();
    chr_dev_init();
    tty_init();
    time_init();
    sched_init();
    buffer_init();
    hd_init();
    floppy_init();
    sti();
    move_to_use_mode();
    if(!fork()){init()};
}
```


## 中断/异常

中断是异步操作....CPU和硬件设备是可以并行操作的,CPU不必等待硬件IO设备的操作结果,当设备完成的时候,由设备发出中断信号告知CPU,CPU立即保存当前的执行情况后处理。。。

这就是操作系统首次实现异步的一个机制: 中断机制

- IO中断
- 时钟中断 进程轮片/定时
- 硬件故障

异常其实也是种中断,只不过通常异常是CPU主动触发的一种中断

- 系统调用 
- 页故障/页错误
- 保护性异常 (读写冲突) 
- 断点调试
- 其他程序异常

总结: 中断是一些外部事件,被动触发的,异常是由正在执行的指令引起的，属于主动触发的....


## 工作原理

CPU会在每条指令执行周期的最后时刻扫描中断寄存器,查看是否有中断信号,若有中断,通过查找中断向量表引出中断处理函数

- 128 0x80 系统调用异常中断
- 32 - 127 外部中断,IO设备中断


举例：IO设备硬中断 

- 打印机给CPU发送中断信号
- CPU处理完当前指令后检测到中断,判断出中断来源并向相关设备发确认信号
- CPU进行`系统调用`,切换到内核态，并将现场保存(程序计数器PC以及程序状态字PSW)
- CPU根据中断向量表,获得该中断相关处理程序(内核)程序的入口地址,将PC设置为该地址,CPU去执行内核中断处理程序
- 中断处理完毕后,CPU检测到中断返回指令,CPU从内核态转为用户态,恢复之前的上下文


举例：系统调用 

每个操作系统都提供几百种系统调用(进程控制、进程通信、文件使用、目录操作、设备管理、信息维护)

- 当CPU执行到特殊的陷入指令的时候(write/read/open/fork/),同样先保存现场,再根据中断向量表,获取中断处理程序,并转交控制权 int 0x80 

- 根据查询系统调用表把控制权转给相应的内核函数 fork 2 / read 3 / write 4 / open 5 / close 6 / waitpid 7 / create 8 / link 9 / unlink 10 / execve 11 / chdir 12 / time 13 

- 当系统调用中涉及到异步操作的时候,比如等待网卡、磁盘相应这种,CPU会转而执行其他的进程,当前进程变为阻塞态...由硬件设备发出硬中断信号 ,否则进行下一步

- 中断函数处理完毕后,CPU检测到中断返回指令,CPU从内核态转为用户态,恢复之前的上下文

```

// write库函数的实现细节
// liunx/include/unistd.h write原型

#define _syscall3(){
    // 这里调用int 0x80进行系统调用,传递参数系统调用号
}

// int 0x80的实现细节
// IDT(中断向量表)表里取出中断处理函数
// 执行完毕之后回到系统调用的地方,将结果存入寄存器
```



## 进程

进程的创建方式

- 系统初始化(init)
- 正在运行的程序执行了创建进程的系统调用(fork)
- 用户请求创建了一个新的进程(点击可执行文件)
- 初始化一个批处理文件(脚本文件执行

进程的状态

- 运行态 ,指的是进程实际占用CPU时间片运行时
- 就绪态 , 就绪态指的是可运行,但因为其他进程正在运行而处于就绪状态
- 阻塞态 , 除非某种外部事件发生,否则进程不能运行

![](./image/runtime.png)

> 进程进行系统调用并不一定都是阻塞的(无需等待外部事件发生),阻塞的原则是需要等待硬件设备的操作.....

多进程的CPU图像

1. 进程时间轮片用完
2. 当前进程阻塞

```
// 调度
schedule(){
    // 找出就绪进程队列中的下一个
    pNew = getNext(ReadyQueue)
    // 进行切换
    switch_to(pCur,pNew); 
}

// 切换
switch_to(pCur,pNew){
    pCur.ax = CPU.ax;
    pCur.bx = CPU.bx;
    .....
    pCur.cs = CPU.cs;
    pCur.retpc = CPU.pc;

    CPU.ax = pNew.ax;
    CPU.bx = pNew.bx;
    CPU.cs = pNew.cs;
    CPU.retpc = pNew.pc;
}
```

## 用户级线程

## 内核级线程


## CPU调度

## 进程同步与信号量

## 死锁处理

## 内存使用与分段










