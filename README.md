<!--
 * @Author: lizhiyuan
 * @Date: 2020-11-21 20:53:10
 * @LastEditors: lizhiyuan
 * @LastEditTime: 2020-12-10 23:33:23
-->
# 操作系统

## 中断/异常

中断是异步操作....CPU和硬件设备是可以并行操作的,CPU不必等待硬件IO设备的操作结果,当设备完成的时候,由设备发出中断信号告知CPU,CPU立即保存当前的执行情况后处理。。。

这就是操作系统首次实现异步的一个机制: 中断机制

- IO中断
- 时钟中断 进程轮片/定时
- 硬件故障

异常其实也是种中断,只不过通常异常是CPU主动触发的一种中断

- 系统调用 
- 页故障/页错误
- 保护性异常 (读写冲突) 
- 断点调试
- 其他程序异常

总结: 中断是一些外部事件,被动触发的,异常是由正在执行的指令引起的，属于主动触发的....


## 工作原理

CPU会在每条指令执行周期的最后时刻扫描中断寄存器,查看是否有中断信号,若有中断,通过查找中断向量表引出中断处理函数

- 128 0x80 系统调用异常中断
- 32 - 127 外部中断,IO设备中断


举例：IO设备硬中断 

- 打印机给CPU发送中断信号
- CPU处理完当前指令后检测到中断,判断出中断来源并向相关设备发确认信号
- CPU进行`系统调用`,切换到内核态，并将现场保存(程序计数器PC以及程序状态字PSW)
- CPU根据中断向量表,获得该中断相关处理程序(内核)程序的入口地址,将PC设置为该地址,CPU去执行内核中断处理程序
- 中断处理完毕后,CPU检测到中断返回指令,CPU从内核态转为用户态,恢复之前的上下文


举例：系统调用 

每个操作系统都提供几百种系统调用(进程控制、进程通信、文件使用、目录操作、设备管理、信息维护)

- 当CPU执行到特殊的陷入指令的时候(write/read/open/fork/),同样先保存现场,再根据中断向量表,获取中断处理程序,并转交控制权 int 0x80 

- 根据查询系统调用表把控制权转给相应的内核函数 fork 2 / read 3 / write 4 / open 5 / close 6 / waitpid 7 / create 8 / link 9 / unlink 10 / execve 11 / chdir 12 / time 13 

- 当系统调用中涉及到异步操作的时候,比如等待网卡、磁盘相应这种,CPU会转而执行其他的进程,当前进程变为阻塞态...由硬件设备发出硬中断信号 ,否则进行下一步

- 中断函数处理完毕后,CPU检测到中断返回指令,CPU从内核态转为用户态,恢复之前的上下文

```
用户调用printf -----> printf展开为int 0x80 -----> 中断处理程序 system_call ----> 查表 sys_call_table ------> __NR_write -----> sys_write 调用

```

## 进程

进程的创建方式

- 系统初始化(init)
- 正在运行的程序执行了创建进程的系统调用(fork)
- 用户请求创建了一个新的进程(点击可执行文件)
- 初始化一个批处理文件(脚本文件执行

进程的状态

- 运行态 ,指的是进程实际占用CPU时间片运行时
- 就绪态 , 就绪态指的是可运行,但因为其他进程正在运行而处于就绪状态
- 阻塞态 , 除非某种外部事件发生,否则进程不能运行

![](./image/runtime.png)

> 进程进行系统调用并不一定都是阻塞的(无需等待外部事件发生),阻塞的原则是需要等待硬件设备的操作.....

多进程的CPU图像

1. 进程时间轮片用完
2. 当前进程阻塞

```
// 调度
schedule(){
    // 找出就绪进程队列中的下一个
    pNew = getNext(ReadyQueue)
    // 进行切换
    switch_to(pCur,pNew); 
}

// 切换
switch_to(pCur,pNew){
    pCur.ax = CPU.ax;
    pCur.bx = CPU.bx;
    .....
    pCur.cs = CPU.cs;
    pCur.retpc = CPU.pc;

    CPU.ax = pNew.ax;
    CPU.bx = pNew.bx;
    CPU.cs = pNew.cs;
    CPU.retpc = pNew.pc;
}
```

## 用户级线程

## 内核级线程


## CPU调度

## 进程同步与信号量

## 死锁处理

## 内存使用与分段










